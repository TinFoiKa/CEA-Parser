"""
This is specifically made for bonus 1 - thrust calculations
"""

import numpy as np
import multivar as mv

# Dict of displacements from the marker
# COMPOSITION DURING EXPANSION FROM INFINITE AREA COMBUSTOR
DISP = {
    "R": 10,
    "P": 14,
    "T": 15,
    "gamma": 26,
    "cstar": 33,
    "Cf": 34,
}

CAPTURE = 40

def mdot(a_star, p, big_t, big_r, gamma):
    """
    Helper function for jsut mdot

    input values are parsed from CEA, accounting for
    A*, p_t, T_t, R, and gamma respectively
    """

    # mdot calculation
    a = a_star*p/np.sqrt(big_t)
    b = np.sqrt(gamma/big_r)
    c = 1 + (gamma-1)/2
    d = - (gamma + 1)/(2*(gamma-1))

    return a * b * (np.pow(c,d))

def thrust_calc(md, c_star, c_tau) -> list[float]:
    """
    Calculation for F = mdot x c* x C_tau x 0.95^2
    """

    return md * c_star * c_tau * np.pow(0.95, 2)


def parse_txt(file: str) -> list[list[float]]:
    """
    This is an override of the function in parse.py to
    be able to encapsulate the values required for mdot calculations
    
    dev (me :<) reminder: cstar and Cf still need to be encapsulated
    
    Results list is returned as a list of list for every variable
    out list formatted as [R(IV), P, T, gamma, cstar, Cf]
    """

    # this is the result matrix (list list)
    results = []

    # just to be safe, I don't think this is wrong
    print(list(DISP.values()))

    # opne (typo also in parse.py) file reading session
    with open(file, "r", encoding="utf-8") as parse:
        # line captures
        reserve = 0
        pp = []

        for line in parse:
            # if key from found (below) is given, iterate reserve lines
            if reserve > 0:
                if reserve == 1:
                    results.append(pp)
                    pp=[]

                print(line, reserve)
                # remember R has different behaviour than all others [48, 57]
                is_r = reserve == CAPTURE - DISP["R"]

                # preserve cstar and Cf at exit [37, 44]
                in_perf = reserve in [CAPTURE - DISP["Cf"], CAPTURE - DISP["cstar"]]

                # all other values found at throat [26, 35]
                r = [48, 57] if is_r else [37, 44] if in_perf else [26,35]

                # with bounds defined, append all
                if reserve in list(CAPTURE - x for x in DISP.values()):
                    fl = float(line[r[0]:r[1]])
                    pp.append(fl)

                reserve -= 1
                continue
            

            if line.find("COMPOSITION DURING EXPANSION FROM INFINITE AREA COMBUSTOR") != -1:
                # encapsulate next 40 lines in the loop
                # (data range is like 53-88, but i'd like to be safe)
                reserve = CAPTURE

    # flip the 2d list 90 degrees
    results = list(map(list, zip(*results)))

    # resultatn list should be in descending order of DISP dict
    print(results)
    # the lion cares for his mental health and you should too
    return results

def thrust_task():
    """
    Show multivariate graph (impl in multivar.py) of each A* change (colour mapped)

    Two graphs shown for Trade 2 and 3 respectively

    In relation to DV thrust

    Data generated by CEA web app
    """
    pvals = parse_txt("cea/pvP.txt")
    rvals = parse_txt("cea/rvP.txt")
    ppars = [500, 400, 200, 150, 100]
    rpars = [1.1, 1.2, 1.3, 1.5, 1.6, 1.7]
    
    # notice that a_star comes from injected data here, not given by CEA
    # TODO: still need to figure out how multivar CEA ouputs are structured
    a = [0.03302, 0.0479044, 0.075184] # TODO: in^2 to m^2 NOT in to m
    
    for vals, pars in zip([pvals, rvals], [ppars, rpars]):
        m_array = []
        
        # dimension 1 is p or r
        for p, big_t, big_r, gamma, c_star, Cf in zip(vals[1], vals[2], vals[0], vals[3], vals[4], vals[5]):
            d_array = []
            # dimension 2 is a_star
            for a_star in a:
                fr = mdot(a_star, p, big_t, big_r, gamma)
                t = thrust_calc(fr, c_star, Cf)
                d_array.append(t)
            
            m_array.append(d_array)

        # m_array now holds all thrust data in a 2d array with a_star change as
        # second axis and pressure/ratio on first
        
        # define layers and push to nd_graph
        layers = [tuple(['Pressure (psia)' if vals == pvals else 'O/F', False, pars]), 
                  tuple(['$A_t (m^2)$', False, a]), 
                  tuple(['Thrust (N)', False, []])]
        mv.nd_graph(np.array(m_array), layers)

if __name__ == "__main__":
    thrust_task()